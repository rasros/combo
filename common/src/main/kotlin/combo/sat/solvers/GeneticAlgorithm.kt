@file:JvmName("GeneticAlgorithm")

package combo.sat.solvers

import combo.math.*
import combo.sat.*
import combo.util.IntHashSet
import combo.util.millis
import combo.util.nanos
import kotlin.jvm.JvmName
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min

/**
 * Steady state Genetic Algorithm Optimizer.
 * See Classifier Systems
 * https://sfi-edu.s3.amazonaws.com/sfi-edu/production/uploads/sfi-com/dev/uploads/filer/2b/07/2b071152-def2-4475-8d18-3161db1bd7e3/92-07-032.pdf
 */
open class GAOptimizer<O : ObjectiveFunction>(val problem: Problem) : Optimizer<O> {

    override var randomSeed: Long
        set(value) {
            this.randomSequence = RandomSequence(value)
        }
        get() = randomSequence.startingSeed
    override var timeout: Long = -1L
    private var randomSequence = RandomSequence(nanos())

    /**
     * The number of solution candidates that is generated by the search. This is the most important parameter to tweak.
     */
    var candidateSize: Int = max(20, min(problem.nbrVariables * 5, 300))

    /**
     * Determines the [Instance] that will be created for solving, for very sparse problems use
     * [IntSetInstanceFactory] otherwise [BitArrayFactory].
     */
    var instanceFactory: InstanceFactory = BitArrayFactory

    /**
     * This contains cached information about satisfied constraints during search. [PropTrackingInstanceFactory] is more
     * efficient for optimizing but uses more memory than [BasicTrackingInstanceFactory]. The default for genetic algorithms
     * is [BasicTrackingInstanceFactory].
     */
    var trackingInstanceFactory: TrackingInstanceFactory = PropTrackingInstanceFactory(problem)

    /**
     * Variables will be initialized according to this for each instance. The default is [RandomInitializer] which
     * initializes uniform at random, consider switching to [combo.sat.WeightInitializer] for [LinearObjective].
     */
    var initializer: ValueInitializer<O> = RandomInitializer()

    /**
     * The search will be restarted up to [restarts] number of time and the best value will be selected from each
     * restart. For SAT solving restarts will be set to [Int.MAX_VALUE].
     */
    var restarts: Int = 1

    /**
     * Percentage of candidate solutions that will be kept using [selection] method in the case of a restart. The
     * other will be randomly generated new candidates.
     */
    var restartKeeps: Double = 0.2

    /**
     * Maximum number of steps for each of the [restarts].
     */
    var maxSteps: Int = max(500, problem.nbrVariables)

    /**
     * Threshold of improvement to stop current iteration in the search.
     */
    var eps: Double = 1E-4

    /**
     * This is the maximum number of steps that can be performed with no improvement on the [O] objective function.
     * It is only applied if a feasible solution is found.
     */
    var stallSteps: Int = max(50, problem.nbrVariables / 4)

    /**
     * The method by which candidate solutions are selected to form the next candidate that is added to the pool of
     * candidates (see also [elimination]).
     */
    var selection: SelectionOperator = TournamentSelection(max(2, candidateSize / 10))

    /**
     * The method by which candidate solution are selected to eliminate from the pool of candidates
     * (see also [selection]).
     */
    var elimination: SelectionOperator = TournamentElimination(max(2, candidateSize / 5))

    /**
     * The recombinaton operator controls the way that new candidates are generated after the initial population.
     */
    var recombination: RecombinationOperator = KPointRecombination(1)

    var recombinationProbability: Double = 1.0

    /**
     * The [mutation] operator in conjunction with the [mutationProbability] adds additional diversity to the candidate
     * solutions. The default flips one random variable with probability 1.
     */
    var mutation: MutationOperator = FixedMutation()

    /**
     * The [mutation] operator in conjunction with the [mutationProbability] adds additional diversity to the candidate
     * solutions. The default flips one random variable with probability 1.
     */
    var mutationProbability: Double = 1.0

    /**
     * In order to discourage the optimizer to converge to an infeasible candidate solution we add an external penalty
     * to the objective function. The default penalty ensures that any infeasible candidate solution has a penalized
     * score that is strictly greater than a feasible solution. In order for that to work the
     * [combo.sat.solvers.ObjectiveFunction.lowerBound] and [combo.sat.solvers.ObjectiveFunction.upperBound] must be
     * implemented and be finite. Otherwise, choose another penalty function that does not rely on bounds.
     */
    var penalty: PenaltyFunction = DisjunctPenalty()

    override fun optimizeOrThrow(function: O, assumptions: Literals): Instance {
        val end = if (timeout > 0L) millis() + timeout else Long.MAX_VALUE
        val lowerBound = function.lowerBound()
        val upperBound = function.upperBound()

        fun score(s: TrackingInstance) = function.value(s).let { it + penalty.penalty(it, s.totalUnsatisfied, lowerBound, upperBound) }


        val candidates = let {
            val instances: Array<TrackingInstance> = Array(candidateSize) {
                trackingInstanceFactory.build(instanceFactory.create(problem.nbrVariables), assumptions, initializer, function, randomSequence.next())
            }
            val scores = DoubleArray(candidateSize) {
                score(instances[it]).also { s ->
                    if (abs(s - lowerBound) < eps && instances[it].totalUnsatisfied == 0)
                        return instances[it].instance
                }
            }
            OptimizerCandidateSolutions(instances, IntArray(instances.size), scores)
        }

        for (restart in 1..restarts) {
            var stalls = 0
            val rng = randomSequence.next()

            for (step in 1L..maxSteps) {
                val eliminated = elimination.select(candidates, rng)
                val recombined = if (rng.nextDouble() < recombinationProbability) {
                    val parent1: Int = selection.select(candidates, rng)
                    val parent2: Int = selection.select(candidates, rng)
                    recombination.combine(parent1, parent2, eliminated, candidates, rng)
                    parent1 != parent2
                } else {
                    // Copy selected individual to eliminated and force mutation
                    val parent: Instance = candidates.instances[selection.select(candidates, rng)].instance
                    val target = candidates.instances[eliminated]
                    for (i in parent.indices) if (target[i] != parent[i]) target.flip(i)
                    false
                }
                if (!recombined || rng.nextDouble() < mutationProbability)
                    mutation.mutate(eliminated, candidates, rng)
                val updatedInstance = candidates.instances[eliminated]
                val score = score(updatedInstance)
                if (abs(score - lowerBound) < eps && updatedInstance.totalUnsatisfied == 0)
                    return updatedInstance

                candidates.scores[eliminated] = score
                if (!candidates.update(eliminated, step, score)) stalls++
                else stalls = 0

                if (millis() > end || (stalls >= stallSteps && restart < restarts) || candidates.minScore == candidates.maxScore) break
            }

            if (restart == restarts || millis() > end) break

            val keep = IntHashSet()
            var tries = 0
            while (keep.size < max(0.2, restartKeeps) * candidateSize || tries++ < candidateSize)
                keep.add(selection.select(candidates, rng))
            tries = 0
            while (keep.size < restartKeeps * candidateSize) keep.add(tries)

            for (i in 0 until candidateSize) {
                if (i in keep) {
                    candidates.update(i, 1, candidates.minScore)
                } else {
                    candidates.instances[i] = trackingInstanceFactory.build(instanceFactory.create(problem.nbrVariables), assumptions, initializer, function, randomSequence.next())
                    @Suppress("UNCHECKED_CAST")
                    (candidates.instances as Array<MutableInstance>)[i] = candidates.instances[i]
                    val newScore = score(candidates.instances[i])
                    candidates.scores[i] = newScore
                    candidates.update(i, 0, newScore)
                }
            }
        }

        val ix = (0 until candidateSize).minBy {
            if (candidates.instances[it].totalUnsatisfied == 0) candidates.scores[it]
            else Double.POSITIVE_INFINITY
        }!!
        if (candidates.instances[ix].totalUnsatisfied == 0)
            return candidates.instances[ix].instance

        if (millis() > end)
            throw TimeoutException(timeout)
        else throw IterationsReachedException(restarts)
    }
}


/**
 * This class changes the default parameters to be suitable for SAT solving.
 */
class GASolver(problem: Problem) : GAOptimizer<SatObjective>(problem), Solver {
    init {
        restarts = 1
        maxSteps = Int.MAX_VALUE
        penalty = LinearPenalty()
        elimination = OldestElimination()
    }

    override fun witnessOrThrow(assumptions: Literals) = optimizeOrThrow(SatObjective, assumptions)
}

class OptimizerCandidateSolutions(override val instances: Array<TrackingInstance>,
                                  val origins: IntArray,
                                  val scores: DoubleArray) : CandidateSolutions {

    override var minScore: Double = Double.POSITIVE_INFINITY
        private set
    override var maxScore: Double = Double.NEGATIVE_INFINITY
        private set
    var oldestOrigin: Int = Int.MAX_VALUE
        private set
    override var oldestCandidate: Int = 0
        private set
    override val nbrCandidates: Int
        get() = instances.size
    override val nbrVariables: Int
        get() = instances[0].size

    init {
        for (i in instances.indices) {
            val s = scores[i]
            if (s < minScore) minScore = s
            if (s > maxScore) {
                maxScore = s
                if (origins[i] <= oldestOrigin) {
                    oldestCandidate = i
                    oldestOrigin = origins[i]
                }
            }
        }
    }

    override fun score(ix: Int) = scores[ix]

    override fun update(ix: Int, step: Long, newScore: Double): Boolean {
        origins[ix] = step.toInt()
        if (oldestCandidate == ix || step < oldestOrigin) {
            oldestOrigin = Int.MAX_VALUE
            for (i in origins.indices) {
                if (origins[i] < oldestOrigin) {
                    oldestOrigin = origins[i]
                    oldestCandidate = i
                    if (oldestOrigin == 0) break
                }
            }
        }
        if (newScore > maxScore) {
            maxScore = newScore
            return false
        }
        if (newScore < minScore) {
            minScore = newScore
            return true
        }
        return false
    }
}
