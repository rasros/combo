package combo.bandit.ga

import combo.bandit.Bandit
import combo.bandit.InstanceData
import combo.bandit.univariate.BanditPolicy
import combo.ga.*
import combo.math.*
import combo.sat.*
import combo.sat.constraints.Conjunction
import combo.sat.solvers.LocalSearchSolver
import combo.sat.solvers.Solver
import combo.util.*
import kotlin.jvm.JvmOverloads
import kotlin.math.max
import kotlin.math.min
import kotlin.random.Random

/**
 * This bandit uses a univariate bandit algorithm, such as [combo.bandit.univariate.ThompsonSampling]. Each instance
 * in the candidate solutions (or gene pool) is a bandit. As new candidates are generated and poor ones are eliminated
 * the bandits arms are added or removed.
 *
 * @param problem the problem contains the [Constraint]s and the number of variables.
 * @param banditPolicy the policy that the next bandit arm is chosen.
 * @param solver the solver will be used to generate [Instance]s that satisfy the constraints from the [Problem].
 */
class GeneticAlgorithmBandit<E : VarianceEstimator> @JvmOverloads constructor(
        val problem: Problem,
        val banditPolicy: BanditPolicy<E>,
        val solver: Solver = LocalSearchSolver(problem).apply {
            this.restarts = 10
            this.randomSeed = randomSeed
            this.timeout = 1000L
        })
    : Bandit<Array<InstanceData<E>>> {

    /**
     * Setting randomSeed will also update the solver randomSeed
     */
    override var randomSeed: Int = nanos().toInt()
        set(value) {
            solver.randomSeed = value
            this.rng = Random(value)
            field = value
        }
    private var rng = Random(randomSeed)

    override var rewards: DataSample = GrowingDataSample()
    override var maximize = true

    /**
     * The number of solution candidates that is generated by the search. This is the most important parameter to tweak.
     * This must be set before any use.
     */
    var candidateSize: Int = max(20, min(problem.nbrVariables * 5, 300))
        set(value) {
            require(!candidatesDelegate.isInitialized()) { "Population size cannot be changed after use." }
            field = value
        }

    /**
     * The method by which candidate solutions are selected to form the next candidate that is added to the pool of
     * candidates (see also [elimination]).
     */
    var selection: SelectionOperator<BanditCandidates<E>> = TournamentSelection(5)

    /**
     * The method by which candidate solution are selected to eliminate from the pool of candidates
     * (see also [selection]).
     */
    var elimination: SelectionOperator<BanditCandidates<E>> = TournamentElimination(3)

    /**
     * The custom selectors for GeneticAlgorithmBandit are allowed to decline to make a selection, such as the
     * [SignificanceTestElimination] selector will fail to eliminate when there are no significantly under-performing
     * bandits. Usually nothing happens in that case, however when an elimination is forced then the fallback
     * elimination is used instead.
     */
    var fallbackElimination: SelectionOperator<BanditCandidates<E>> = OldestElimination()

    /**
     * Run the elimination with this period. If set to 1 it will run each update.
     */
    var eliminationPeriod: Int = 10
    private var replacementCount = 0

    /**
     * Probability that the recombination operator is used when eliminating a candidate. Note that recombination
     * operator is always uniform, to ensure that only feasible candidates enter the candidate pool.
     * During elimination, if recombination does not occur then mutation is forced.
     */
    var recombinationProbability = 0.5f

    /**
     * The [mutation] operator in conjunction with the [mutationProbability] adds additional diversity to the candidate
     * solutions. The default flips one random variable with probability 1.
     */
    var mutation: RateMutationOperator = FixedRateMutation()

    /**
     * The [mutation] operator in conjunction with the [mutationProbability] adds additional diversity to the candidate
     * solutions. The default flips one random variable with probability 1.
     * During elimination, if recombination does not occur then mutation is forced.
     */
    var mutationProbability = 0.1f

    /**
     * Whether duplicates are allowed in the candidates. If set to false, then randomly generated instances will replace
     * duplicated instances. This will result in failure if the number of solutions to the [problem] are less than the
     * [candidateSize].
     */
    var allowDuplicates: Boolean = true

    /**
     * This is used during mutation to propagate mutations. There is no good reason to not set it other than memory
     * consumption in creating the implication digraph.
     */
    var implicationDigraph: ImplicationDigraph? = null

    private val candidatesDelegate: Lazy<BanditCandidates<E>> = lazy {
        val set: HashSet<Instance>? = if (allowDuplicates) null else HashSet()
        val instances: Array<MutableInstance> = Array(candidateSize) {
            var instance = solver.witnessOrThrow() as MutableInstance
            while (set != null && set.contains(instance)) instance = solver.witness() as MutableInstance
            set?.add(instance)
            instance
        }
        val candidates = BanditCandidates(instances, banditPolicy.baseData())
        for (e in candidates.estimators.values) banditPolicy.addArm(e)
        candidates
    }

    private val candidates by candidatesDelegate

    override fun chooseOrThrow(assumptions: IntCollection): Instance {
        banditPolicy.round(rng)
        val assumption: Constraint = if (assumptions.isNotEmpty()) Conjunction(assumptions) else Tautology

        val (instance, _) = candidates.estimators.maxBy { (i, e) ->
            if (assumption.satisfies(i)) banditPolicy.evaluate(e, maximize, rng)
            else Float.NEGATIVE_INFINITY
        }!!

        return if (!assumption.satisfies(instance)) {
            val eliminated = let {
                val e1 = elimination.select(candidates, rng)
                if (e1 < 0) {
                    val e2 = fallbackElimination.select(candidates, rng)
                    if (e2 < 0) rng.nextInt(candidateSize)
                    else e2
                } else e1
            }
            // This instance will always be a non-duplicate so we don't need to check for that
            val newInstance = solver.witnessOrThrow(assumptions) as MutableInstance
            candidates.replaceCandidate(eliminated, newInstance)
            newInstance
        } else instance
    }

    override fun update(instance: Instance, result: Float, weight: Float) {
        rewards.accept(result, weight)
        val estimator = candidates.estimators[instance] ?: return
        banditPolicy.update(estimator, result, weight)
        candidates.update(estimator.mean)

        if (++replacementCount >= eliminationPeriod && candidates.nbrUpdates > candidateSize) {
            val eliminated = elimination.select(candidates, rng)
            if (eliminated < 0) return
            replacementCount = 0
            var newInstance: MutableInstance? = null
            val recombined = if (rng.nextFloat() < recombinationProbability) {
                val parent1 = selection.select(candidates, rng)
                val instance1 = candidates.instances[parent1]
                val parent2 = selection.select(candidates, rng)
                val instance2 = candidates.instances[parent2]
                val intersect = IntList()
                for (i in instance1.indices) {
                    val lit1 = instance1.literal(i)
                    val lit2 = instance2.literal(i)
                    if (lit1 == lit2) intersect.add(lit1)
                }
                newInstance = solver.witness(intersect) as MutableInstance
                parent1 != parent2
            } else false
            if (newInstance == null)
                newInstance = candidates.instances[selection.select(candidates, rng)].copy()

            if (!recombined || rng.nextFloat() < mutationProbability) {
                val mr = mutation.mutationRate(problem.nbrVariables, rng)

                var forcedAssumption: IntList? = null
                var index = rng.nextGeometric(mr) - 1
                while (index < problem.nbrVariables) {
                    if (forcedAssumption == null) {
                        forcedAssumption = IntList()
                        forcedAssumption.add(!index.toLiteral(newInstance[index]))
                    }
                    val literal = !index.toLiteral(newInstance[index])
                    newInstance.set(literal)
                    implicationDigraph?.propagate(literal, newInstance)
                    index += rng.nextGeometric(mr)
                }
                newInstance = solver.witness(forcedAssumption ?: EmptyCollection, newInstance) as MutableInstance?
                        ?: newInstance
            }
            while (!allowDuplicates && newInstance!! in candidates.duplications)
                newInstance = solver.witness() as MutableInstance

            candidates.replaceCandidate(eliminated, newInstance!!)?.run {
                banditPolicy.removeArm(this)
            }
            if (candidates.duplications[newInstance]!!.size == 1)
                banditPolicy.addArm(candidates.estimators[newInstance]!!)
        }
    }

    override fun exportData(): Array<InstanceData<E>> {
        return Array(candidateSize) {
            InstanceData(candidates.instances[it], candidates.estimators[candidates.instances[it]]!!)
        }
    }

    /**
     * Replace the current candidates and their data with that of the [historicData]. [candidateSize] will be set to
     * the length of the [historicData].
     */
    override fun importData(historicData: Array<InstanceData<E>>) {
        /*
        // TODO
        if (candidateSize != historicData.size) candidateSize = historicData.size
        var worstScore = Float.NEGATIVE_INFINITY
        candidates.minScore = Float.POSITIVE_INFINITY
        candidates.maxScore = Float.NEGATIVE_INFINITY
        candidates.estimators.clear()
        candidates.duplications.clear()
        for (i in historicData.indices) {
            candidates.instances[i] = historicData[i].instance as MutableInstance
            candidates.origins[i] = 0
            if (candidates.estimators[i].mean > worstScore) {
                worstScore = candidates.estimators[i].mean
                candidates.oldestCandidate = i
            }
            candidates.minScore = min(candidates.minScore, candidates.estimators[i].mean)
            candidates.maxScore = max(candidates.maxScore, candidates.estimators[i].mean)
            candidates.addCandidate(i, historicData[i].data)
        }
        candidates.oldestOrigin = 0L
         */
    }
}
