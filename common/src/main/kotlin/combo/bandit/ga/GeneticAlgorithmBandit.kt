package combo.bandit.ga

import combo.bandit.Bandit
import combo.bandit.InstanceData
import combo.bandit.univariate.BanditPolicy
import combo.ga.*
import combo.math.*
import combo.sat.*
import combo.sat.constraints.Conjunction
import combo.sat.solvers.LocalSearchSolver
import combo.sat.solvers.Solver
import combo.util.*
import kotlin.jvm.JvmOverloads
import kotlin.math.max
import kotlin.math.min
import kotlin.random.Random

/**
 * This bandit uses a univariate bandit algorithm, such as [combo.bandit.univariate.ThompsonSampling]. Each instance
 * in the candidate solutions (or gene pool) is a bandit. As new candidates are generated and poor ones are eliminated
 * the bandits arms are added or removed.
 *
 * @param problem the problem contains the [Constraint]s and the number of variables.
 * @param banditPolicy the policy that the next bandit arm is chosen.
 * @param solver the solver will be used to generate [Instance]s that satisfy the constraints from the [Problem].
 */
class GeneticAlgorithmBandit<E : VarianceEstimator> @JvmOverloads constructor(
        val problem: Problem,
        val banditPolicy: BanditPolicy<E>,
        val solver: Solver = LocalSearchSolver(problem).apply {
            this.restarts = 10
            this.randomSeed = randomSeed
            this.timeout = 1000L
        })
    : Bandit<Array<InstanceData<E>>> {

    /**
     * Setting randomSeed will also update the solver randomSeed. If the bandit is already initialized this will not
     * change the current candidates.
     */
    override var randomSeed: Int = nanos().toInt()
        set(value) {
            solver.randomSeed = value
            this.rng = Random(value)
            field = value
        }
    private var rng = Random(randomSeed)

    override var rewards: DataSample = BucketSample()
    override var maximize = true
        set(value) {
            field = value
            if (candidatesDelegate.isInitialized())
                candidates.maximize = value
        }

    /**
     * The number of solution candidates that is generated by the search. This is the most important parameter to tweak.
     * The default value is set very low.
     */
    var candidateSize: Int = max(10, min(problem.nbrVariables * 2, 100))
        set(value) {
            field = value
            resizeCandidates()
        }

    /**
     * The method by which candidate solutions are selected to form the next candidate that is added to the pool of
     * candidates (see also [elimination]).
     */
    var selection: SelectionOperator<BanditCandidates<E>> = TournamentSelection(5)

    /**
     * The method by which candidate solution are selected to eliminate from the pool of candidates
     * (see also [selection]).
     */
    var elimination: SelectionOperator<BanditCandidates<E>> = EliminationChain(
            SignificanceTestElimination(),
            TournamentElimination(3))

    /**
     * Run the elimination with this period. If set to 1 it will run each update.
     */
    var eliminationPeriod: Int = 10
    private var replacementCount = 0

    /**
     * Probability that the recombination operator is used when eliminating a candidate. Note that recombination
     * operator is always uniform, to ensure that only feasible candidates enter the candidate pool.
     * During elimination, if recombination does not occur then mutation is forced.
     */
    var recombinationProbability = 0.5f

    /**
     * The [mutation] operator in conjunction with the [mutationProbability] adds additional diversity to the candidate
     * solutions. The default flips one random variable with probability 1.
     */
    var mutation: MutationRate = FixedRateMutation()

    /**
     * The [mutation] operator in conjunction with the [mutationProbability] adds additional diversity to the candidate
     * solutions. The default flips one random variable with probability 1.
     * During elimination, if recombination does not occur then mutation is forced.
     */
    var mutationProbability = 0.1f

    /**
     * Whether duplicates are allowed in the candidates. If set to false, then randomly generated instances will replace
     * duplicated instances. This will result in failure if the number of solutions to the [problem] are less than the
     * [candidateSize].
     */
    var allowDuplicates: Boolean = true
        set(value) {
            field = value
            resizeCandidates()
        }

    /**
     * This is used during mutation to propagate mutations. There is no good reason to not set it other than memory
     * consumption in creating the implication digraph.
     */
    var implicationDigraph: ImplicationDigraph? = null

    /**
     * Maximum number of restarts before solver gives up during initial. This is reset
     */
    var maxSolverRestarts: Int = 10

    /**
     * Minimum number of sample that must be accrued before a candidate can be eliminated.
     */
    var minEliminationSamples: Float = 4.0f
        set(value) {
            candidates.minSamples = value
            field = value
        }

    private val step = AtomicLong()

    private val candidatesDelegate: Lazy<BanditCandidates<E>> = lazy {
        val instances: Array<Instance> = if (!allowDuplicates && solver.isComplete()) {
            solver.asSequence().take(candidateSize).toList().toTypedArray()
        } else {
            val set: MutableSet<Instance>? = if (allowDuplicates) null else HashSet<Instance>()
            Array(candidateSize) {
                var instance: Instance? = null
                for (i in 0..maxSolverRestarts) {
                    instance = solver.witness() ?: continue
                    if (set != null && instance in set) continue
                    else set?.add(instance)
                    break
                }
                instance ?: throw IterationsReachedException(
                        "Max iterations $maxSolverRestarts reached during initialization.")
            }
        }
        BanditCandidates(instances, minEliminationSamples, maximize, banditPolicy).also {
            for (e in it.estimators.values) banditPolicy.addArm(e)
        }
    }

    private val candidates by candidatesDelegate

    private fun resizeCandidates() {
        if (!candidatesDelegate.isInitialized()) return
        val keptInstances: MutableCollection<Instance> = if (allowDuplicates) ArrayList() else HashSet()
        keptInstances.addAll(candidates.instances)
        if (keptInstances.size == candidateSize) return

        // Eliminate candidates
        while (candidates.nbrCandidates > candidateSize)
            candidates.removeCandidate(selectForElimination(true))

        // Add candidates
        val uniqueInstances = if (keptInstances is MutableSet<*>) keptInstances else null
        while (candidates.nbrCandidates < candidateSize) {
            var instance: Instance? = solver.witness()
            while (instance == null || (uniqueInstances != null && instance in uniqueInstances)) instance = solver.witness()
            val i: Instance = instance
            uniqueInstances?.add(i)
            candidates.addCandidate(instance)
        }
    }

    /**
     * Ensure that candidates are initialized.
     */
    fun initialize() {
        candidates
    }

    val isInitialized get() = candidatesDelegate.isInitialized()

    override fun chooseOrThrow(assumptions: IntCollection): Instance {
        val assumption: Constraint = if (assumptions.isNotEmpty()) Conjunction(assumptions) else Tautology

        val t = step.getAndIncrement()
        val (instance, _) = candidates.estimators.maxBy { (i, e) ->
            if (assumption.satisfies(i)) banditPolicy.evaluate(e, t, maximize, rng)
            else Float.NEGATIVE_INFINITY
        }!!

        return if (!assumption.satisfies(instance)) {
            // This instance will always be a non-duplicate so we don't need to check for that
            val newInstance = solver.witnessOrThrow(assumptions)
            candidates.replaceCandidate(selectForElimination(true), newInstance)
            newInstance
        } else instance
    }

    override fun update(instance: Instance, result: Float, weight: Float) {
        rewards.accept(result, weight)
        candidates.update(instance, result, weight)

        if (++replacementCount >= eliminationPeriod && candidates.step >= candidates.nbrCandidates) {

            // Select eliminated candidate
            val eliminated = selectForElimination(false)
            if (eliminated < 0) return
            replacementCount = 0
            var newInstance: MutableInstance? = null

            // Perform recombination
            val recombined = if (rng.nextFloat() < recombinationProbability) {
                val parent1 = selection.select(candidates, rng)
                val instance1 = candidates.instances[parent1]
                val parent2 = selection.select(candidates, rng)
                val instance2 = candidates.instances[parent2]
                val intersect = IntList()
                for (i in instance1.indices) {
                    val lit1 = instance1.literal(i)
                    val lit2 = instance2.literal(i)
                    if (lit1 == lit2) intersect.add(lit1)
                }
                newInstance = solver.witness(intersect) as MutableInstance?
                parent1 != parent2
            } else false

            // Recombination failed/not performed?
            if (newInstance == null)
                newInstance = candidates.instances[selection.select(candidates, rng)].copy()

            // Perform mutation
            if (!recombined || rng.nextFloat() < mutationProbability) {
                val mr = mutation.rate(problem.nbrVariables, rng)

                var forcedAssumption: IntList? = null
                var index = rng.nextGeometric(mr) - 1
                while (index < problem.nbrVariables) {
                    if (forcedAssumption == null) {
                        forcedAssumption = IntList()
                        forcedAssumption.add(!index.toLiteral(newInstance[index]))
                    }
                    val literal = !index.toLiteral(newInstance[index])
                    newInstance.set(literal)
                    implicationDigraph?.propagate(literal, newInstance)
                    index += rng.nextGeometric(mr)
                }
                newInstance = solver.witness(forcedAssumption ?: EmptyCollection, newInstance) as MutableInstance?
                        ?: newInstance
            }

            // Replace with random if it is a duplicate
            while (!allowDuplicates && newInstance!! in candidates.estimators)
                newInstance = solver.witness() as MutableInstance

            candidates.replaceCandidate(eliminated, newInstance!!)?.run {
                banditPolicy.removeArm(this)
            }
            if (!candidates.isDuplicated(newInstance))
                banditPolicy.addArm(candidates.estimators[newInstance]!!)
        }
    }

    override fun exportData(): Array<InstanceData<E>> {
        return Array(candidates.nbrCandidates) {
            InstanceData(candidates.instances[it], candidates.estimator(it)!!)
        }
    }

    @Suppress("UNCHECKED_CAST")
    override fun importData(data: Array<InstanceData<E>>, restructure: Boolean) {
        if (restructure) {
            val newInstances = ArrayList<Instance>()
            val newData = HashMap<Instance, E>()
            var uniqueInstances: MutableSet<Instance>? = null
            if (allowDuplicates) {
                for ((i, e) in data) {
                    newInstances.add(i)
                    newData.getOrPut(i) { candidates.estimators[i]?.combine(e) as? E ?: e }
                }
            } else {
                uniqueInstances = HashSet()
                for ((i, e) in data) {
                    if (i !in uniqueInstances) {
                        uniqueInstances.add(i)
                        newInstances.add(i)
                        newData.getOrPut(i) { candidates.estimators[i]?.combine(e) as? E ?: e }
                    }
                }
            }

            if (newInstances.size < candidateSize) {
                val ordered = candidates.instances.sortedBy {
                    val s = candidates.estimators[it]!!.mean
                    if (maximize) s else -s
                }.toMutableList()
                while (newInstances.size < candidateSize) {
                    val i = ordered.removeAt(ordered.lastIndex)
                    if (uniqueInstances != null && i in uniqueInstances) continue
                    uniqueInstances?.add(i)
                    newInstances.add(i)
                    newData.getOrPut(i) { candidates.estimators[i]!! }
                }
            }
            newInstances.shuffle(rng)
            candidates.replaceCandidates(newInstances.toTypedArray(), newData)
            candidateSize = newInstances.size
        } else {
            // Just update existing candidates estimates
            for ((i, newE) in data) {
                val thisE = candidates.estimators[i] ?: continue
                @Suppress("UNCHECKED_CAST")
                candidates.estimators[i] = thisE.combine(newE) as E
            }
        }
    }

    private fun selectForElimination(force: Boolean): Int {
        val e = elimination.select(candidates, rng)
        return if (force && e < 0) rng.nextInt(candidates.nbrCandidates)
        else e
    }
}
