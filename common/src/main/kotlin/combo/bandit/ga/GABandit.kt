package combo.bandit.ga

import combo.bandit.Bandit
import combo.bandit.InstanceData
import combo.bandit.univariate.BanditPolicy
import combo.math.*
import combo.sat.*
import combo.sat.constraints.Conjunction
import combo.sat.solvers.LocalSearchSolver
import combo.sat.solvers.Solver
import combo.util.*
import kotlin.jvm.JvmOverloads
import kotlin.math.max
import kotlin.math.min
import kotlin.random.Random

// TODO doc: Not possible to choose recominator operator

class GABandit<E : VarianceEstimator> @JvmOverloads constructor(
        val problem: Problem,
        val banditPolicy: BanditPolicy<E>,
        val solver: Solver = LocalSearchSolver(problem).apply {
            this.restarts = 10
            this.randomSeed = randomSeed
            this.timeout = 1000L
        }) : Bandit<Array<InstanceData<E>>> {

    /**
     * Setting randomSeed will also update the solver randomSeed
     */
    override var randomSeed: Long
        set(value) {
            solver.randomSeed = value
            this.randomSequence = RandomSequence(value)
        }
        get() = randomSequence.startingSeed
    private var randomSequence = RandomSequence(nanos())

    override var rewards: DataSample = GrowingDataSample()
    override var maximize = true

    /**
     * The number of solution candidates that is generated by the search. This is the most important parameter to tweak.
     */
    var candidateSize: Int = max(20, min(problem.nbrVariables * 5, 300))
        set(value) {
            require(!candidatesDelegate.isInitialized()) { "Population size cannot be changed after use." }
            field = value
        }

    /**
     * TODO
     */
    var selection: SelectionOperator = TournamentSelection(5)

    var elimination: SelectionOperator = OldestElimination()
    var fallbackElimination: SelectionOperator = elimination

    var replacementPeriod: Int = 1

    private var replacementCount = 0

    /**
     * TODO
     */
    var recombinationProbability = 0.5f

    /**
     * TODO
     */
    var mutation: RateMutationOperator = FixedRateMutation()

    /**
     * TODO
     */
    var mutationProbability = 0.1f

    private val candidatesDelegate: Lazy<GABanditCandidateSolutions> = lazy {
        val estimators: Array<VarianceEstimator> = Array(candidateSize) {
            banditPolicy.baseData().also { banditPolicy.addArm(it) }
        }
        val instances: Array<MutableInstance> = Array(candidateSize) { solver.witness() as MutableInstance }
        GABanditCandidateSolutions(instances, LongArray(candidateSize), estimators)
    }

    private val candidates by candidatesDelegate

    @Suppress("UNCHECKED_CAST")
    override fun chooseOrThrow(assumptions: Literals): Instance {
        val rng = randomSequence.next()
        banditPolicy.beginRound(rng)
        val con = Conjunction(collectionOf(*assumptions))
        val ix = (0 until candidateSize).maxBy { i ->
            val s = if (con.satisfies(candidates.instances[i])) banditPolicy.evaluate(candidates.estimators[i] as E, rng)
            else Float.NEGATIVE_INFINITY
            if (maximize) s else -s
        }!!
        return if (!con.satisfies(candidates.instances[ix])) {
            val eliminated = let {
                val e1 = elimination.select(candidates, rng)
                if (e1 < 0) {
                    val e2 = fallbackElimination.select(candidates, rng)
                    if (e2 < 0) rng.nextInt(candidateSize)
                    else e2
                } else e1
            }
            (solver.witnessOrThrow(assumptions) as MutableInstance).also {
                replaceInstance(eliminated, it)
            }
        } else candidates.instances[ix]
    }

    private fun replaceInstance(eliminated: Int, newInstance: MutableInstance) {
        val eliminatedInstance = candidates.instances[eliminated]
        candidates.map[eliminatedInstance]?.run {
            remove(eliminated)
            if (isEmpty()) candidates.map.remove(eliminatedInstance)
        }
        candidates.map.getOrPut(newInstance) { IntHashSet() }.add(eliminated)
        candidates.instances[eliminated] = newInstance
        val e = banditPolicy.baseData()
        candidates.estimators[eliminated] = e
        candidates.update(eliminated, candidates.currentStep, candidates.estimators[eliminated].mean)
    }

    @Suppress("UNCHECKED_CAST")
    override fun update(instance: Instance, result: Float, weight: Float) {
        rewards.accept(result, weight)
        val indices = candidates.map[instance] ?: return
        val itr = indices.iterator()
        val ix = itr.nextInt()

        banditPolicy.completeRound(candidates.estimators[ix] as E, result, weight)
        while (itr.hasNext()) {
            val ix1 = itr.nextInt()
            banditPolicy.updateData(candidates.estimators[ix1] as E, result, weight)
        }

        if (replacementCount > ++replacementPeriod) {
            replacementCount = 0
            val rng = randomSequence.next()
            val eliminated = elimination.select(candidates, rng)
            if (eliminated < 0) return
            val newInstance: MutableInstance
            val recombined = if (rng.nextFloat() < recombinationProbability) {
                val parent1 = selection.select(candidates, rng)
                val instance1 = candidates.instances[parent1]
                val parent2 = selection.select(candidates, rng)
                val instance2 = candidates.instances[parent2]
                val intersect = IntList()
                for (i in instance1.indices) {
                    val lit1 = instance1.literal(i)
                    val lit2 = instance2.literal(i)
                    if (lit1 == lit2) intersect.add(lit1)
                }
                val assumptions = intersect.toArray()
                val recombined = solver.witnessOrThrow(assumptions)
                candidates.instances[eliminated] = recombined as MutableInstance
                parent1 != parent2
            } else {
                val parent = candidates.instances[selection.select(candidates, rng)]
                candidates.instances[eliminated] = parent.copy()
                false
            }
            if (!recombined || rng.nextFloat() < mutationProbability) {
                TODO("mutation should work")
            }
            //replaceInstance(eliminated, )
            candidates.estimators[eliminated] = banditPolicy.baseData()
            candidates.update(eliminated, candidates.currentStep, candidates.estimators[eliminated].mean)
        }
    }

    override fun exportData(): Array<InstanceData<E>> {
        return Array(candidateSize) {
            @Suppress("UNCHECKED_CAST")
            (InstanceData(candidates.instances[it], candidates.estimators[it] as E))
        }
    }

    override fun importData(historicData: Array<InstanceData<E>>) {
        if (candidateSize != historicData.size) candidateSize = historicData.size
        var worstScore = Float.NEGATIVE_INFINITY
        candidates.minScore = Float.POSITIVE_INFINITY
        candidates.maxScore = Float.NEGATIVE_INFINITY
        for (i in historicData.indices) {
            candidates.instances[i] = historicData[i].instance as MutableInstance
            candidates.estimators[i] = historicData[i].data
            candidates.origins[i] = 0
            if (candidates.estimators[i].mean > worstScore) {
                worstScore = candidates.estimators[i].mean
                candidates.oldestCandidate = i
            }
            candidates.minScore = min(candidates.minScore, candidates.estimators[i].mean)
            candidates.maxScore = max(candidates.maxScore, candidates.estimators[i].mean)
        }
        candidates.oldestOrigin = 0L
    }


}


/*class FrequencyUpdatePolicy(val elimination: SelectionOperator,
                            val updateFrequency: Int,
                            override var maximize: Boolean)
    : UpdatePolicy {
    private var count = 0
    override fun update(candidates: CandidateSolutions, rng: Random, forced: Boolean): Int {
        count++
        if (count > updateFrequency || forced) {
            count = 0
            return elimination.select(candidates, rng)
        }
        return -1
    }
}*/

/**
 * TODO and can only be used with [GABandit].
 */
class SignificanceTestElimination(val estimators: Array<out VarianceEstimator>, val alpha: Float = 0.05f) : SelectionOperator {
    override fun select(candidates: CandidateSolutions, rng: Random): Int {
        TODO("not implemented")
    }
}

/**
 * This eliminates the candidate/bandit with smallest number of plays and can only be used with [GABandit].
 */
class SmallestCountElimination(val minWeightedCount: Float = 0.0f) : SelectionOperator {
    override fun select(candidates: CandidateSolutions, rng: Random): Int {
        val c = candidates as GABanditCandidateSolutions
        var min = Float.POSITIVE_INFINITY
        var minIx = -1
        for (i in c.estimators.indices) {
            val n = c.estimators[i].nbrWeightedSamples
            if (n >= minWeightedCount && n < min) {
                min = n
                minIx = i
            }
        }
        return minIx
    }
}

class FallbackSelection(val eliminators: Array<out SelectionOperator>) : SelectionOperator {
    override fun select(candidates: CandidateSolutions, rng: Random): Int {
        for (e in eliminators) {
            val ix = e.select(candidates, rng)
            if (ix >= 0) return ix
        }
        return rng.nextInt(candidates.nbrCandidates)
    }
}

private class GABanditCandidateSolutions(override val instances: Array<MutableInstance>,
                                         val origins: LongArray,
                                         val estimators: Array<VarianceEstimator>) : CandidateSolutions {

    override var minScore: Float = Float.POSITIVE_INFINITY
    override var maxScore: Float = Float.NEGATIVE_INFINITY
    var oldestOrigin: Long = Long.MAX_VALUE
    override var oldestCandidate: Int = 0
    override val nbrCandidates: Int
        get() = instances.size
    override val nbrVariables: Int
        get() = instances[0].size
    var currentStep = 0L

    // TODO update this when recombinations appear
    var map: MutableMap<Instance, IntHashSet> = HashMap<Instance, IntHashSet>().apply {
        for (i in instances.indices) getOrPut(instances[i]) { IntHashSet() }.add(i)
    }

    init {
        for (i in instances.indices) {
            val s = estimators[i].mean
            if (s < minScore) minScore = s
            if (s > maxScore) {
                maxScore = s
                if (origins[i] <= oldestOrigin) {
                    oldestCandidate = i
                    oldestOrigin = origins[i]
                }
            }
        }
    }

    override fun score(ix: Int) = estimators[ix].mean

    override fun update(ix: Int, step: Long, newScore: Float): Boolean {
        currentStep++
        origins[ix] = currentStep
        if (oldestCandidate == ix || step < oldestOrigin) {
            oldestOrigin = Long.MAX_VALUE
            for (i in origins.indices) {
                if (origins[i] < oldestOrigin) {
                    oldestOrigin = origins[i]
                    oldestCandidate = i
                    if (oldestOrigin == 0L) break
                }
            }
        }
        if (newScore > maxScore) {
            maxScore = newScore
            return false
        }
        if (newScore < minScore) {
            minScore = newScore
            return true
        }
        return false
    }
}
